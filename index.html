<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D 擲筊動畫</title>
  <style>
    body {
      margin: 0;
      background: #111;
      font-family: 'Microsoft JhengHei', Arial, sans-serif;
      overflow: hidden;
      color: white;
    }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 10;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    #result {
      position: absolute;
      top: 60px;
      left: 20px;
      z-index: 10;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    button {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      font-size: 20px;
      background: linear-gradient(45deg, #b22222, #ff4444);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(178, 34, 34, 0.4);
      transition: all 0.3s ease;
      font-family: inherit;
    }
    button:hover {
      background: linear-gradient(45deg, #cc3333, #ff5555);
      transform: translateX(-50%) translateY(-2px);
      box-shadow: 0 6px 20px rgba(178, 34, 34, 0.6);
    }
    button:active {
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body>
  <div id="info">3D 擲筊動畫</div>
  <div id="result"></div>
  <button onclick="throwBuabei()">擲筊</button>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, cup1, cup2, isAnimating = false;
    
    function init() {
      // 創建場景
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      
      // 創建相機
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 8, 12);
      camera.lookAt(0, 0, 0);
      
      // 創建渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // 添加光照
      const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // 創建地板
      const floorGeometry = new THREE.PlaneGeometry(30, 30);
      const floorMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x2a2a2a,
        transparent: true,
        opacity: 0.8
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -0.5;
      floor.receiveShadow = true;
      scene.add(floor);
      
      // 創建筊杯
      createDivinationBlocks();
      
      // 開始渲染循環
      animate();
      
      // 窗口大小調整
      window.addEventListener('resize', onWindowResize, false);
    }
    
    function createDivinationBlocks() {
      // 筊杯幾何體 - 使用橢圓形狀
      const cupGeometry = new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.7);
      
      // 材質
      const cupMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa2222,
        shininess: 30,
        specular: 0x222222
      });
      
      // 創建兩個筊杯
      cup1 = new THREE.Mesh(cupGeometry, cupMaterial);
      cup2 = new THREE.Mesh(cupGeometry, cupMaterial.clone());
      
      cup1.position.set(-2, 2, 0);
      cup2.position.set(2, 2, 0);
      
      cup1.castShadow = true;
      cup2.castShadow = true;
      cup1.receiveShadow = true;
      cup2.receiveShadow = true;
      
      scene.add(cup1);
      scene.add(cup2);
    }
    
    function throwBuabei() {
      if (isAnimating) return;
      
      isAnimating = true;
      document.getElementById('result').innerHTML = '';
      
      // 重置位置
      cup1.position.set(-2, 2, 0);
      cup2.position.set(2, 2, 0);
      cup1.rotation.set(0, 0, 0);
      cup2.rotation.set(0, 0, 0);
      
      const cups = [cup1, cup2];
      const results = [];
      let completedAnimations = 0;
      
      cups.forEach((cup, index) => {
        // 隨機旋轉和拋物線參數
        const rotationSpeed = {
          x: (Math.random() - 0.5) * 20,
          y: (Math.random() - 0.5) * 20,
          z: (Math.random() - 0.5) * 20
        };
        
        const throwForce = {
          x: (Math.random() - 0.5) * 4,
          y: 8 + Math.random() * 4,
          z: (Math.random() - 0.5) * 4
        };
        
        const startTime = Date.now();
        const duration = 2000;
        const startPos = cup.position.clone();
        
        function animateCup() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          
          if (t < 1) {
            // 拋物線運動
            const gravity = -12;
            cup.position.x = startPos.x + throwForce.x * t;
            cup.position.y = startPos.y + throwForce.y * t + 0.5 * gravity * t * t;
            cup.position.z = startPos.z + throwForce.z * t;
            
            // 旋轉
            cup.rotation.x += rotationSpeed.x * 0.02;
            cup.rotation.y += rotationSpeed.y * 0.02;
            cup.rotation.z += rotationSpeed.z * 0.02;
            
            requestAnimationFrame(animateCup);
          } else {
            // 落地後確定最終狀態
            cup.position.y = 0;
            
            // 決定正反面
            const isFlat = Math.random() < 0.5; // 平面朝上
            const finalRotation = isFlat ? 0 : Math.PI;
            
            cup.rotation.x = finalRotation;
            cup.rotation.y = Math.random() * Math.PI * 2;
            cup.rotation.z = 0;
            
            results[index] = isFlat;
            completedAnimations++;
            
            // 當兩個筊杯都完成動畫時顯示結果
            if (completedAnimations === 2) {
              showResult(results);
              isAnimating = false;
            }
          }
        }
        
        // 添加延遲讓動畫更自然
        setTimeout(animateCup, index * 100);
      });
    }
    
    function showResult(results) {
      const [cup1Result, cup2Result] = results;
      let resultText = '';
      
      if (cup1Result && cup2Result) {
        resultText = '聖筊 - 神明同意';
      } else if (!cup1Result && !cup2Result) {
        resultText = '陰筊 - 神明不同意';
      } else {
        resultText = '笑筊 - 請重新擲筊';
      }
      
      document.getElementById('result').innerHTML = `結果: ${resultText}`;
      
      // 添加結果特效
      setTimeout(() => {
        const resultDiv = document.getElementById('result');
        resultDiv.style.fontSize = '22px';
        resultDiv.style.color = cup1Result && cup2Result ? '#4CAF50' : 
                               (!cup1Result && !cup2Result ? '#f44336' : '#ff9800');
        setTimeout(() => {
          resultDiv.style.fontSize = '18px';
        }, 300);
      }, 500);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // 相機繞場景旋轉
      const time = Date.now() * 0.0005;
      camera.position.x = Math.cos(time) * 12;
      camera.position.z = Math.sin(time) * 12;
      camera.lookAt(scene.position);
      
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // 初始化場景
    init();
  </script>
</body>
</html>